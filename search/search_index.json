{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Play framework"},{"location":"/index.html#play-framework","text":"Client and server backed by Play framework.","title":"Play framework"},{"location":"/index.html#client","text":"API documentation\nThe Endpoints interpreter fixes the Endpoint[A, B] type to a function from A to Future[B]:\ncopysourcecase class Endpoint[A, B](request: Request[A], response: Response[B])\n    extends (A => Future[B])\nThis means that, given the following endpoint definition:\ncopysourceval someResource: Endpoint[Int, String] =\n  endpoint(get(path / \"some-resource\" / segment[Int]()), ok(textResponse))\nIt can be invoked as follows:\ncopysourceval eventuallyString: Future[String] = someResource(42)","title":"Client"},{"location":"/index.html#server","text":"API documentation","title":"Server"},{"location":"/index.html#endpoints","text":"The Endpoints interpreter provides a routesFromEndpoints operation that turns a sequence of endpoints with their implementation into a play.api.routing.Router.Routes value that can be integrated to your Play application.\nFor instance, given the following endpoint definition:\ncopysourceval someResource: Endpoint[Int, String] =\n  endpoint(get(path / \"some-resource\" / segment[Int]()), ok(textResponse))\nIt can be implemented as follows:\ncopysourceval routes: Router.Routes =\n  routesFromEndpoints(\n    someResource.implementedBy(x => s\"Received $x\")\n  )\nIn practice, the routes are put in a class taking an endpoints4s.play.server.PlayComponents parameter. An HTTP server can then be started as in the following example:\nobject Main {\n  // JVM entry point that starts the HTTP server\n  def main(args: Array[String]): Unit = {\n    val playConfig = ServerConfig(port = sys.props.get(\"http.port\").map(_.toInt).orElse(Some(9000)))\n    NettyServer.fromRouterWithComponents(playConfig) { components =>\n      val playComponents = PlayComponents.fromBuiltInComponents(components)\n      new CounterServer(playComponents).routes\n        .orElse(new DocumentationServer(playComponents).routes)\n    }\n    ()\n  }\n}","title":"Endpoints"},{"location":"/index.html#chunkedentities","text":"The ChunkedEntities interpreter fixes the type Chunks[A] to akka.stream.scaladsl.Source[A, _].\nFor instance, given the following chunked endpoint definition:\ncopysourceval logo: Endpoint[Unit, Chunks[Array[Byte]]] =\n  endpoint(get(path / \"logo.png\"), ok(bytesChunksResponse))\nIt can be implemented as follows:\ncopysourceimport org.apache.pekko.stream.scaladsl.FileIO\nimport java.nio.file.Paths\n\nval logoHandler =\n  logo.implementedBy { _ =>\n    FileIO.fromPath(Paths.get(\"/foo/bar/logo.png\")).map(_.toArray)\n  }","title":"ChunkedEntities"},{"location":"/index.html#error-handling","text":"When the server processes requests, three kinds of errors can happen: the incoming request doesn’t match any endpoint, the request does match an endpoint but is invalid (e.g. one parameter has a wrong type), or an exception is thrown.","title":"Error handling"},{"location":"/index.html#the-incoming-request-doesn-t-match-any-endpoint","text":"In that case, the router constructed by endpoints4s can’t do anything. You have to deal with such errors in the usual Play way: by using a custom play.api.http.HttpErrorHandler.","title":"The incoming request doesn’t match any endpoint"},{"location":"/index.html#the-incoming-request-is-invalid","text":"In that case, endpoints4s returns a “Bad Request” (400) response reporting all the errors in a JSON array. You can change this behavior by overriding the handleClientErrors method.","title":"The incoming request is invalid"},{"location":"/index.html#an-exception-is-thrown","text":"If an exception is thrown during request decoding, or when running the business logic, or when encoding the response, endpoints4s returns an “Internal Server Error” (500) response reporting the error in a JSON array. You can change this behavior by overriding the handleServerError method.","title":"An exception is thrown"}]}